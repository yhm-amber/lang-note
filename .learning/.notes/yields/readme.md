
## `yield`

lang: 

- js
- py
- lua
- ...

points: 

- 这是一种特殊的 `return` 。含义是「产出」，「产出」后还可以从中断（执行产出）的位置继续执行。
  
  - 如在 JS 里
    
    形式与 `return` 一致，都是 `关键字 相关的值` 的写法。
    
  - 如在 Lua 里
    
    它不是关键字，而是库函数，但相关的项目是不变的。因而此时的编写与使用的形式也是大同小异的。
    
  
- 必须在特定的结构里。
  
  - 如在 JS 里
    
    只能写在特殊的函数里，即 generator 函数。
    
    具体的写法就是声明函数的关键字是 `function*` ，
    比一般的多了个星号。
    
    对它的调用也是取得一个有着 `.next()` 方法的对象，
    然后调用这个方法才能一个一个取得「产出」的值。
    
  - 如在 Lua 里
    
    用了它的函数须进入特定的结构里。
    
    即须要 `coroutine.create(functionname)` 取得一个对象，
    然后 `coroutine.resume(这个对象)` 。
    
    这对应于 JS 里的 `gen().next()` 。
    
  
- 一定是写在 `return` 之前的。
  
  （这是自然。）
  
- ...

## `async`

promise: 

- `fetch(...).then((res) => {somenewres})`
  
  一个承诺对象有 `then` 方法，
  传参应该是一个函数。
  
  那个 (匿名) 函数的参数是这个承诺承诺要返回的结果。
  
  那个函数的结果也会是 `then` 本身的结果，
  因而 `then` 可以用 *链式调用* 取缔掉 *嵌套的地狱* 。
  
- `async`
  
  它标记特殊的函数种类。
  
  这种的函数永远返回 `Promise` 种类的对象。
  
  `fetch` 就是这种函数。
  
  它里面可以调用别的 `async` 函数，
  并且可以在调用代码左侧增加 `await` 关键字，
  这会使得原本要在 `then( (response)=>{...} )` 这样的
  形式下才能使用的回调结果 `response` 现在就是
   `await fetch(...)` 这一坨的返回值了，
  从而，现在你已经得到了结果，处理就是了，
  不需要把处理逻辑套在一串儿 `.then( ... )` 里了。
  
- ...
