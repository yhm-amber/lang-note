library(magrittr); 

1 %>% `-`() ; # [1] -1
1 %>% `-` ; # [1] -1

minus = \(x) \(y) x - y ;

1 %>% minus(2) ; # 2> Error in x(., 2) : unused argument (2)
1 %>% minus(2)() ; # [1] 1

1 %>% minus()(2) ; # 2> Error in x()(., 2) : unused argument (2)
1 %>% minus(.)(2) ; # 2> Error in x(.)(., 2) : unused argument (2)

(1 %>% minus(.))(2) ; # [1] -1
(1 %>% minus)(2) ; # [1] -1
magrittr::`%>%`(1,x)(2) ; # [1] -1

### 👺 magrittr 的 %>% 只认右边对象语法中的最后一个写着的括号。
### 👺 一个括号都没有的时候，才会自动补一个 (.) 。


### 👺 与 4.1.0 后新增的 Native 管道对比

"aa" %>% paste ("bb") ; # [1] "aa bb"
"aa" |> paste ("bb") ; # [1] "aa bb"
"aa" %>% paste (.,"bb",.) ; # [1] "aa bb aa"
"aa" |> paste (_,"bb",_) ;
## 2> 
## Error in paste("_", "bb", "_") : 
##   pipe placeholder can only be used as a named argument (<input>:1:9)

"aa" %>% paste (...=.,"bb",...=.) ; # [1] "aa bb aa"
"aa" |> paste (...=_,"bb",...=_) ;
## 2> 
## Error in paste(... = "_", "bb", ... = "_") : 
##   pipe placeholder may only appear once (<input>:1:9)

"aa" %>% paste ("bb",...=.) ; # [1] "bb aa"
"aa" |> paste ("bb",...=_) ; # [1] "bb aa"

### 👺 magrittr 管道提供的语法更灵活，写法也更多。
### 👺 Native 管道提供的语法不那么灵活、限制较多（这有时是好事有时不利于简洁代码）。
### 👺 Native 管道是直接被解释为 lhs 位于 rhs 最后一个括号的第一个参数，完全零性能影响。
### 👺 magrittr 管道是用函数在第三方库实现的，当然虽不是零代价抽象但代价也没多少。
### 👺 magrittr 管道身上最大的代价其实是需要引入第三方库， Native 管道因而在避免引入库的场景下会更加优雅。
### 👺 但由于历史原因， Native 管道是在新版本才能用的，且 magrittr 管道极为成熟，因而后者反而会在另一些受限场景胜出。

### 👺 总之，两者区别不是太大：
### 👺 - 一个灵活一个刻板，各有各的好处。
### 👺 - 一个是库一个要新版，各有各的优势场景。
### 👺 可根据需要使用。比如：
### 👺 - 无版本必须多旧的限制、且要尽量少依赖地制作自己的库，用 Native 管道。
### 👺 - 更青睐与刻板带来的严谨性，用 Native 管道。
### 👺 - 介意 %>% 这种写法过于容易被覆盖因而不够严谨，用 Native 管道（ |> 没那么容易被覆盖，但 %>% 可以被定义为中坠函数而达到覆盖效果。可以赋值 `%>%` 为 NA 来恢复第三方库该管道的功能）。
### 👺 - 更愿意让代码不具备语言特色、乐于与其他语言（ OCaml, Elixir, ... ）的约定习惯保持一致，用 Native 管道。
### 👺 - 不介意引入第三方库、青睐灵活的语法、希望可以有简洁美观的代码、或者更喜欢简洁明确的错误提示，用 magrittr 管道（有整个系列哦）。





### 👺 %>% 的 rhs 有没有被大括号包裹效果是不同的。

1 %>% list(.+2,.*2,.-2,./2) |> identical (list(1,3,2,-1,0.5)) ; # [1] TRUE
1 %>% list(.,.+2,.*2,.-2,./2) |> identical (list(1,3,2,-1,0.5)) ; # [1] TRUE

### 👺 这两个是一回事。因为 . 占位符（ placeholder ）全都是别的函数的参数。
### 👺 即，作为 rhs 的 name 的 list 的最后面一个参数列表括号没有直接用过占位符。
### 👺 这样一来就会被当作使用了是不用占位符的语法，那么，管道就会自行在该最后一个参数列表括号的第一个参数位置添加占位符。

### 👺 可以看下面这个式子的结果相当于什么。
### 👺 它在 list 函数的参数列表直接用了起码一次占位符（而不是用给别的函数的参数列表），因而占位符没有被隐式地插在开头。

1 %>% list(.+2,.*2,.,.-2,./2) |> identical (list(3,2,1,-1,0.5)) ; # [1] TRUE

### 👺 如果你不希望这种隐式造成的乱搞，那就在你明确无论如何也不需要自动补占位符到第一个参数的情况下，用花括号。

1 %>% {list(.+2,.*2,.-2,./2)} |> identical (list(3,2,-1,0.5)) ; # [1] TRUE
1 %>% (\(z) list(z+2,z*2,z-2,z/2)) |> identical (list(3,2,-1,0.5)) ; # [1] TRUE

### 👺 有了花括号，也就等同于是像这样定义了一个闭包。
### 👺 由于 %>% 有下述简化规则，只写一个函数名（闭包对象）即会被自动补充空括号然后在该最末括号自动补占位符，
### 👺 这意味着上面写在 rhs 位置的闭包就会被立即调用，而等价过来的花括号语法也就应当是同样效果了。

1 %>% (\(z) list(z+2,z*2,z-2,z/2))(.) |> identical (list(3,2,-1,0.5)) ; # [1] TRUE
1 %>% (\(z) list(z+2,z*2,z-2,z/2))() |> identical (list(3,2,-1,0.5)) ; # [1] TRUE
1 %>% (\(z) list(z+2,z*2,z-2,z/2)) |> identical (list(3,2,-1,0.5)) ; # [1] TRUE

### 👺 这是最基本的简化规则（或者说隐式自动补全规则）。

### 👺 更复杂的组合例子。
### 👺 下面这个例子，就相当于是另一种意思了。

1 %>% {(\(z) list(z+2,z*2,z-2,z/2))} ; # \(z) list(z+2,z*2,z-2,z/2)
1 %>% (\(x)(\(z) list(z+2,z*2,z-2,z/2))) ; # \(z) list(z+2,z*2,z-2,z/2)

### 👺 这俩是一回事。因为：

1 %>% {(\(z) list(z+2,z*2,z-2,z/2))} %>% {.(3)} |> identical (list(3+2,3*2,3-2,3/2)) ; # [1] TRUE
1 %>% (\(x)(\(z) list(z+2,z*2,z-2,z/2))) %>% {.(3)} |> identical (list(3+2,3*2,3-2,3/2)) ; # [1] TRUE

### 👺 可以看到， 1 没有被作用到任何地方，其原因在这块的第二行更明显。
### 👺 换句话说，这是 1 和 3 都被用上的例子：

1 %>% {(\(z) list(z+2,.*2,z-2,./2))} %>% {.(3)} |> identical (list(3+2,1*2,3-2,1/2)) ; # [1] TRUE
1 %>% (\(x)(\(z) list(z+2,x*2,z-2,x/2))) %>% {.(3)} |> identical (list(3+2,1*2,3-2,1/2)) ; # [1] TRUE

### 👺 由于 a %>% b 相当于 a %>% b(.) ，所以 1 被带入上面的 x 。
### 👺 由于 g %>% {.(3)} 相当于 g %>% (\(f) f(3)) 或者 g %>% (\(f) f(3)) (.) ，
### 👺 所以 3 被代入给上一个管道返回的那个闭包里去了，这个闭包的参数就是 z 。

