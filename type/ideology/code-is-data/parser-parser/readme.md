一套代码，依据解释器的不同而具备不同的意义。

比如同一段 ~lisp~ 代码，将其作为这个解释器的输入时会被解释为有序列表，作为另一个解释器输入时又可以是无序的键值对。这就造就了一种灵活（或许还优雅）的操作：指定不同的解释应用于同一数据，取得需要的几种特性。

看起来大概就是这种形式：

~~~ nu
((a 1) (b 2) (c 3) (d 4)) | parse list kv ## like: [a:1, b:2, c:3, d:4]
((a 1) (b 2) (c 3) (d 4)) | parse list tuple ## like: [(a,1), (b,2), (c,3), (d,4)]
((m ((a 1) (b 2))) (n ((c 3) (d 4))))) | parse map map kv ## like: {m:{a:1, b:2}, n:{c:3, d:4}}
~~~

上面左边是把 `如何理解数据的标记` 记录在了数据以外，右边是譬如 `Python` 之类的流行语言把 `如何理解数据的标记` 同数据本身融合在一起记录。

两种方法各有所长。

左边的方案，不论编写还是阅读都没有右边那么显眼。但其实如果能妥当格式化外加给编辑器附加特定功能，这应该也不算大问题。

右边的方案，对编写和阅读的有利是显而易见的（这可能也是为什么它会流行），不过灵活度——特别是这些语言的实现的灵活或优雅的程度——就不如前者了。
