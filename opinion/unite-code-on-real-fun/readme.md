
如何结构 (复用) 你那有趣的代码。

## Prefer Composition Over Inheritance

组合好过继承。

继承相对于前者的好处，仅仅是你的 method 可以
少传一个参数，而只需要用 this 。

但这正是麻烦的地方 —— 特别是对阅读代码来说，
它造就了不必要的隐式，从而不是「祛魅」而是「增魅」，
就如同糊弄人的江湖术士把没有魔法的东西说得好像
有魔法一样 —— 但对于 coder 们来说，
被糊弄的首先仍然还是自己。

（就算没人看你的代码，你也要看的，对吧？ bro ？）

组合是什么呢？

不要搞什么 abstract class 也不要搞子类父类
的继承关系， *打破家长制* ， childs 和 parent 之间
的关系被「祛魅」为单纯地 …… 在有联系的地方，有
联系，仅此而已，而不是含糊不清。

你可以让你的任何一个类，里面的方法都只是一个静态
的函数。不要用 this ，允许某个参数可以把需要传入
的某种类型的对象传进去，取缔掉那个 this ，这就够了。

显式，而不要隐式。这样你想单独把这函数拎出来
调试也很方便，对吧？无需被上下文困扰，因为上下文
也 TM 是你必须要在调用的时候显式传入的东西 —— 因而，
你不需要进入函数的定义并依靠 IDE 的魔力蹦来蹦去，
你也可以知道，当前正在被处理的上下文，
它 TND 究竟是什么。

…… 在 Scala 里，只能有这种函数的「类」是 Object 。
在 Java 里这些函数则是 static function 。
那，然后呢？对象和它的方法？

跟本来说，对象不需要方法。
但你可以动用一些技巧，让 `fun(x, arg, ...)` 可以
借助某种机制而也能够写作 `x.fun(arg, ...)` 。
这在每种语言里都不太一样， Python 的设计就很有趣，
另外像 Elixir 里的管道那样的方案也是不错的。
 ( JS 里加入 `Promise` 从而能用 `.then` 把
嵌套回调写成链式调用，要做的也是同样的事情。) 

—— 你看，这一切又都指向了管道风格的编程，或者
更进一步 …… 反应式的编程。
它或许还可以进一步变得简洁，但这已经是别的话题了。

而代码的美学，总而言之，还是在于祛魅。

—— 就像我们平常描述事物时那样。

（这是很重要的事情。我说真的。
（不光实用性，它甚至还具有政治层面的先进性，
即祛魅对先进 (被压迫) 阶级有利而反过来的加魅则
经常对落后反动的 (压迫人的) 阶级有利 …… 当然
这又扯远了 …… ））

------

「那么 Java 里的继承机制就要放着不用了吗？」

也不必。可以用来干啥？可以参考
《 A Little Java, A Few Patterns 》。🙃

（我保证会很有趣的。 …… 我不是指书的风格。）

-----

以及 …… 确实地，在组合的 code 方式下，
得以被还原为了函数 (the-real-fun) 的「前方法」，
它也可以不必再是某个（必然不会是充分考虑了的设计下
的）「基类」的重写。

所谓「重写」隐含了 **附庸** 的意味，而先进的理念
总会倡导「**主体思想**」之类的东西，告诉你，不要只
想照搬别人家的成功范例、实事求是地根据自己的实际情况
来灵活决定，这才是唯一的 (真的具备现实性的) 出路。

不必再作为「谁的重写」这样一种「非标准的永远是
特例的」事物而存在了的，也就是被「还原为了函数
原来样貌」 (这是我个人的说法哈) 了的函数，由于摆
脱了「旧世界的继承烙印」，它也就成为了一个独立的
函数（功能） —— 因而你也才能把它单独拎出来并能够就
这样也可以极为方便**且清晰**地完成你的调试。（而且
在实际使用的时候也仍还会像调试的时候一样清晰。🙃）

—— 毕竟，谁也不是自称能预言一切的跳大神，一个事物的
真正的「本质」永远就是这个等待着你与它进行名为「实践」
的「互动」的，这玩意儿本身。所谓「表象」这样的称呼，
也都只是你在你知道了你自己之前理解不太全面之后，
才会叫出口的玩意儿。

……

说白了，还是 ***祛魅*** 。

也就是，确实是现实地存在一些似乎是刻意设计上去的，
「人为的门槛儿」，而如果可以只是删掉它们，真正的知识
 (而不是那种「庸人自扰」似的人为生造的知识) 不会受到
任何损害，还能够宛如褪去了外衣后的真实胴体 (譬如在我
们共和国天津市的海河边的那些雕塑) 一样，把它原本的美
连同它的所有真相都原原本本地铺展在你眼前。

—— 然后，一切都可以很简单。

就好像，「继承」也不是什么特殊的东西。它也只是一种普通
的「关系」 (Relationship) 罢了，比起别的关系没什么
特殊或者高贵的地方。

—— 要体现在代码的层面就是：想知道你原来苦心编造的
「继承关系」，在被「祛魅」从而得到了它的还原 (或
者说真正的所谓 *取回了自己的本质* ) 以后，你能
在哪儿找到它吗？「看你的函数和函数还有数据
彼此是如何发生关系的」就够了，仅此而已。

……

本质，在有意义的语境下，指的就是事物本身。
那个只能随着交互来确定而不是脱离实际空想就能确定的
「本身」。

-----

—— 接下来，你只需再用上提供自语言的「多态」的能力
就好了，这样就能把看起来好像平摊在一起因而杂乱了的
东西做出了一个并不复杂的树的结构的「规整」 —— 从而，
用的时候也就不是只能规定「只有某某 Class 可进入」而是
「只要携带了某个标签 (interface/tag) 的都可进入」。

你可以用 interface (for Java) 或者另外的称呼或
者机制 (在另外的语言/平台里) 来达到「多态」的目的。

而且，你也并没有违反「面向对象」 —— 这玩意儿的精髓
不就是「封装」和「多态」嘛！🙃

------

> 把要用到的东西以接口的形式作为参数传进来，
> 所谓「依赖注入 (Dependency Injection) 」
> 干的也就是这么个事儿。
> 

不是在一个实现里吧它需要用到的功能写死，
而是允许运营期间再去指定在某个需要放置某类
模块的位置到底放置具体什么样实现的模块。

也就是说，你如果想看汽车用了哪款电池，
你应当去看主线代码中调用汽车生成的部分，
而不是去看汽车自己的实现。

这就是依赖注入。多态是支撑它存在的一个方案。

## Abstraction

> 抽象就是共性。
> 

—— 《唯物论辩证法讲授提纲》 毛泽东

对于程序，抽象本质上就是减少程序本身的信息。

可以动态进入的都变成动态进入。
这意味着明确哪些是必须静态的部分，
这也就是明确程序本身的范畴界线。

界线以内，程序本身，
也就是「这个程序的所有可能情况」之间的共性。

而不同的运行实例，
就是这一系列情况内的不同个性。

同时，这界线内的，
也是程序在它所在集合中的个性的体现。

程序要想成为程序就必须是很多实例的共性。
但也必须是有限的很多实例的共性，
那么该共性也就是还程序的特性。

—— 归根结底来说，要是不能成为特性，
又如何被识别为「一个特定的共性」呢？

## Disenchantment

如果你认为一个人做得不够好，
你可以具体指出。

具体有多种具体的方案，
譬如举例怎样比怎样好，
或者哪怕只是说「感觉对方用力姿势不太对」
也算。

如果只是说「感到对方不会做这件事」，
便不能够形成任何有效沟通。

因为你没有明确你得出这个结论的理由，
哪怕只是大致说说、迟一些说说，都没有。

没有凭据，只有审判。
凭据仿佛成了某种不可言说的东西
被神秘笼罩。

而祛魅，就是指明凭据或现象的原因，
总之，避免「神秘笼罩」的发生。

对于一个程序，它跟本来说就是
把一堆具体的东西指定一个称呼，
然后让你可以不用关心这堆东西。

这里面也存在笼罩，但如果要避免神秘，
被笼罩的就应当尽可能小，小到极限。

譬如，移动电话的内部构造并不神秘，
无非就是一块带触控屏幕电路板和一块电池外面套壳。

而如果禁止用户自行更换电池，手机的内部
就会变更神秘一些。那么，祛魅就是
让它的电池可以更换了。

相应地，「赋魅」的价值在于取得对一事物的控制权。
电池依然是可以便于更换的，但必须只针对有特殊设备或者
技能的人群来说。此时，「祛魅」只在有限的范围内发生，
而除此之外的范围，这一实体/行为也就得以被「赋魅」。

如果是，任何人，只要取得某个标签就可以
使用这些设备或具备相应技能，而失去标签就无法发挥这些
技能，那么，此时，这个标签也被「赋魅」了。

可能只是很简单的事情，却变成了「只有获得特定的
标签/能力/身份才能取得 (一部分) 控制权」这样的情况，
简单的事情被「人为地」变得不简单，那么，
利益绑定着控制权，「不同的阶级」也就被实现在了
现实的世界里面 —— 它的成熟就是控制权的不断细分，
这也是阶层的不断细分，连并列关系、分支关系等等这些
 *关系* 也都彼此复杂地穿插了起来，变得「不可描述」，
一场规模巨大的「赋魅」也就完成了，而对它的打破
也就是对必然的「质变」而言无法规避的事情。

—— 这，便是「祛魅」如何在现世中被实现其存在的了。

「习以为常」并不是祛魅。恰恰相反，它是「赋魅」的凭依。

—— 说不清楚，却不会感到不适，从而不会对说清楚再有所
争取，这，就是「习以为常」或者说所谓「常识」。

## Functional

*邱奇数* 就是一种对计算功能的祛魅方案。

算数也好，布尔也好，乃至于一个类型系统，都不过是各种
预定的小的函数的组合而已。

它告诉你，你已经习以为常的各种你并不明白的、或者是
常识性地认定为「无法被明白」的那些东西，其实
「不过就是如此这般而已」。
